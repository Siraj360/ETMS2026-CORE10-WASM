@page "/course-performance"
@using ETMS2026CORE10WA.Model
@using ETMS2026CORE10WA.Components.Core
@using ETMS2026CORE10WA.Components.Info
@using System.Net.Http.Json
@using System.Text.Json
@using Blazored.LocalStorage
@using Microsoft.AspNetCore.Components
@using System.Net.Http
@using Microsoft.Extensions.DependencyInjection
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager NavigationManager
@code
{
    int index = 1;
}
<PageTitle>ETMS : Training Course Performance Summary</PageTitle>
<div class="row mb-2 border-bottom my-2">
    <div class="col-md-8">
        <h4><i class="fa-solid fa-chart-line me-2"></i>Training Course Performance Summary</h4>
    </div>
    <div class="col-md-4">
    
    </div>
</div>

@if (courseList == null)
{
    <Loader />
}
else
{
    <table class='table table-sm table-borderless'>
        <tbody>
            @foreach (var course in courseList)
            {
                
                CourseInfo courseInfo = ToCourseInfo(course, employeeCourseList, employeeList);


                <CourseUI index="@index" OnStatusChanged="@StatusChanged"
                    CourseInfo="courseInfo"></CourseUI>

                index++;

            }
        </tbody>
    </table>
}

<br />
<br />

@code {


   

    // --- RAW DATA LISTS (Targets for JSON/Store) ---
    private List<Employee> employeeList = new();
    private List<Course> courseList = new();
    private List<EmployeeCourse> employeeCourseList = new();

    private const string EmployeeListKey = "EmployeeList_Data";
    private const string CourseListKey = "CourseList_Data";
    private const string EmployeeCourseListKey = "EmployeeCourseList_Data";

    private CourseInfo ToCourseInfo(
       Course course,
       List<EmployeeCourse> employeeCourseList, // The full raw junction list
       List<Employee> employeeList)             // The full raw employee list
    {
        // 1. Map properties from the raw Course object to CourseInfo
        CourseInfo courseInfo = new CourseInfo
        {
            CourseID = course.CourseID,
            RowId = course.RowId,
            Name = course.Name,
            Description = course.Description,
            Code = course.Code,

            // Initialize navigation lists
            // Note: EmployeeList on CourseInfo holds raw Employee objects
            EmployeeList = new List<Employee>(),
            EmployeeCourseList = new List<EmployeeCourse>()
        };

        // 2. Filter the junction table (EmployeeCourse) for this specific course
        List<EmployeeCourse> relatedEmployeeCourses = employeeCourseList
            .Where(ec => ec.CourseID == course.CourseID)
            .ToList();

        // 3. Populate the related Employee objects
        foreach (var ec in relatedEmployeeCourses)
        {
            // Find the matching Employee object in the master list (employeeList)
            // Using FirstOrDefault() is safer than First() in case data is inconsistent
            Employee? employee = employeeList.FirstOrDefault(e => e.EmployeeID == ec.EmployeeID);

            if (employee != null)
            {
                courseInfo.EmployeeList.Add(employee);
            }
        }

        // 4. Assign the filtered junction data
        courseInfo.EmployeeCourseList = relatedEmployeeCourses;

        return courseInfo;
    }


    private async Task StatusChanged(int employeeCourseID)
    {
        Console.WriteLine($"Parent received status change for ID: {employeeCourseID}");

        // 1. Find the specific record in the raw list
        var recordToUpdate = employeeCourseList
            .FirstOrDefault(ec => ec.EmployeeCourseID == employeeCourseID);

        if (recordToUpdate != null)
        {
            // 2. Toggle the isComplete status
            recordToUpdate.isComplete = !recordToUpdate.isComplete;

            // Optionally, update completion/update dates (good practice)
            if (recordToUpdate.isComplete)
            {
                recordToUpdate.CompletedOn = DateTime.Now;
            }
            recordToUpdate.UpdatedOn = DateTime.Now;

            Console.WriteLine($"Toggled status for EC ID {employeeCourseID}: isComplete = {recordToUpdate.isComplete}");

            // 3. Save the entire updated list back to local storage
            try
            {
                await LocalStorage.SetItemAsync(EmployeeCourseListKey, employeeCourseList);
                Console.WriteLine($"Successfully saved updated EmployeeCourseList to local store.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CACHE WRITE ERROR] Failed to save {EmployeeCourseListKey}: {ex.Message}");
            }


             StateHasChanged();
        }
        else
        {
            Console.WriteLine($"Error: EmployeeCourse record with ID {employeeCourseID} not found.");
        }
    }


    protected override async Task OnInitializedAsync()
    {
        int index = 1;
        
        // Set raw lists to null for loading indicator (assuming they are class fields)
        employeeList = null!;
        courseList = null!;
        employeeCourseList = null!;

        var httpClient = HttpClientFactory.CreateClient();
        httpClient.BaseAddress = new Uri(NavigationManager.BaseUri);

        try
        {
            // 1. Load RAW Data (The three list<T> fields)
            employeeList = await LoadDataFromCacheOrHttp<List<Employee>>(
                EmployeeListKey,
                "etms-data/EmployeeList.json", httpClient
            ) ?? new List<Employee>();


            courseList = await LoadDataFromCacheOrHttp<List<Course>>(
                CourseListKey,
                "etms-data/CourseList.json", httpClient
            ) ?? new List<Course>();

            if (courseList.Any())
            {
                // Sort the list by EmployeeID in ascending order (default)
                courseList = courseList
                    .OrderBy(ec => ec.Name)
                    .ToList();
            }

            employeeCourseList = await LoadDataFromCacheOrHttp<List<EmployeeCourse>>(
                EmployeeCourseListKey,
                "etms-data/EmployeeCourseList.json", httpClient
            ) ?? new List<EmployeeCourse>();

            // Check if data is present before proceeding with conversion/join
           
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FATAL DATA LOAD ERROR: {ex.Message}");
            // Ensure all lists are non-null and empty on failure
            employeeList = new List<Employee>();
            courseList = new List<Course>();
            employeeCourseList = new List<EmployeeCourse>();
          
        }

       
        StateHasChanged();
    }

    // --- LoadDataFromCacheOrHttp<T> METHOD (Your Logic) ---
    // This is the core logic that retrieves data from cache (store) OR HTTP (json).
    private async Task<T> LoadDataFromCacheOrHttp<T>(string storageKey, string url, HttpClient httpClient) where T : new()
    {
        // Helper function to serialize and log the first few items of a collection
        void LogDataContents(string source, T dataToLog)
        {
            if (dataToLog is System.Collections.IEnumerable enumerable)
            {
                var collection = enumerable.Cast<object>().ToList();
                var count = collection.Count;
                var sample = collection.Take(3).ToList();

                Console.WriteLine($"--- [DEBUG DATA LOG - {storageKey}] ---");
                Console.WriteLine($"Source: {source}, URL/Key: {(source == "CACHE" ? storageKey : url)}, Total Count: {count}");

                // Log full data for the first three items
                Console.WriteLine($"Sample Data ({sample.Count} items):");
                foreach (var item in sample)
                {
                    var itemJson = System.Text.Json.JsonSerializer.Serialize(item, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
                    Console.WriteLine($"- Item:\n{itemJson}");
                }
                Console.WriteLine("------------------------------------------");
            }
        }


        // --- 1. CHECK LOCAL STORAGE (Cache Read Guarded) ---
        if (LocalStorage != null)
        {
            try
            {
                Console.WriteLine($"[CACHE READ] Attempting to retrieve key: {storageKey}");
                var cachedData = await LocalStorage.GetItemAsync<T>(storageKey);

                if (cachedData != null && !cachedData.Equals(default(T)))
                {
                    // FIX: Check if the collection is empty. If it is, treat it as a cache miss.
                    if (cachedData is System.Collections.ICollection collection && collection.Count == 0)
                    {
                        Console.WriteLine($"[CACHE:EMPTY] {storageKey} found but is empty. Forcing HTTP fetch.");
                        // Fall through to HTTP fetch
                    }
                    else
                    {
                        LogDataContents("CACHE", cachedData);
                        return cachedData; // Cache hit, return valid data
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CACHE ERROR] Failed to read {storageKey} from Local Storage: {ex.Message}");
            }
        }

        // --- 2. FETCH FROM HTTP (If cache failed or was empty) ---
        T data = new T();
        Console.WriteLine($"[HTTP FETCH] Fetching URL: {url}");

        try
        {
            var response = await httpClient.GetAsync(url);
            response.EnsureSuccessStatusCode();

            var jsonContent = await response.Content.ReadAsStringAsync();

            // 🛑 LOGGING FULL RAW JSON CONTENT 🛑
            Console.WriteLine($"[FULL JSON LOG] {storageKey} raw content fetched from URL:");
            // Console.WriteLine(jsonContent); // Keeping this line commented out to reduce overwhelming logs
            // ---------------------------------

            // Deserialization happens here
            data = System.Text.Json.JsonSerializer.Deserialize<T>(jsonContent) ?? new T();

            // Log the deserialized C# object content
            LogDataContents("HTTP JSON", data);

            // --- 3. SAVE TO CACHE ---
            if (LocalStorage != null && !data.Equals(default(T)))
            {
                try
                {
                    await LocalStorage.SetItemAsync(storageKey, data);
                    Console.WriteLine($"[CACHE WRITE] Successfully saved {storageKey} to Local Storage.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[CACHE WRITE ERROR] Failed to save {storageKey}: {ex.Message}");
                }
            }

            return data;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[HTTP ERROR] Failed to fetch or deserialize {url}: {ex.Message}");
            return new T();
        }
    }
}

}
