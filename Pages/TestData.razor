@page "/testdata"
@using ETMS2026CORE10WA.Model
@using ETMS2026CORE10WA.Components.Core
@using System.Net.Http.Json
@using System.Text.Json
@using Blazored.LocalStorage
@using Microsoft.AspNetCore.Components
@using System.Net.Http
@using Microsoft.Extensions.DependencyInjection
@inject HttpClient Http
@inject ILocalStorageService LocalStorage
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager NavigationManager


@code {
    int ix = 1;
}

<PageTitle>ETMS : Employee Training Management System</PageTitle>

<div class="row mb-2 border-bottom my-2">
    <div class="col-md-8">
        <h4>ETMS : Employee Training Management System</h4>
    </div>
    <div class="col-md-4">
        @*  <a type="button" class="btn btn-dark btn-sm float-right" href="/addemployee">Create New Employee</a>*@
    </div>
</div>

@if (employeesCourseInfoList == null)
{
    <Loader />
}
else
{
    int ix = 1; // initialize counter
                <table class='table table-sm table-bordered table-striped table-hover shadow'>
                    <thead>
                        <tr class="fs-5">
                            <th colspan="4" class="text-center table-warning" scope="col">Employee</th>
                            <th colspan="2" class="text-center table-secondary" scope="col">Training Course</th>
                        </tr>
                    </thead>
                    <tbody>
            @foreach (var info in employeesCourseInfoList)
            {
                string tdClass = info.isComplete ? "table-success" : "table-danger";

                <tr>
                    <th scope="row" class="text-center">@ix</th>
                    <td class="@info.cellCSS">@info.EmployeeInfo?.Name</td>
                    <td class="@info.cellCSS text-center">
                        <strong>@info.TotalEmployeeCompleted / @(info.TotalEmployeeNotStarted + info.TotalEmployeeCompleted)</strong>
                        &nbsp;
                        <span class="badge rounded-pill bg-warning float-end me-2">
                            @info.PercentEmployeCompleted
                        </span>
                    </td>
                    <td class="text-center @tdClass">
                        @if (info.isComplete)
                        {
                            <i class="fa-solid fa-circle-check fs-4 text-success"></i>
                        }
                        else
                        {
                            <i class="fa-solid fa-circle-xmark fs-4 text-danger"></i>
                        }
                    </td>
                    <td>
                        <strong>@info.CourseInfo?.Code</strong> : @info.CourseInfo?.Name
                    </td>
                    <td class="text-center @tdClass">
                        <strong>@info.TotalCourseCompleted / @(info.TotalCourseNotStarted + info.TotalCourseCompleted)</strong>
                        &nbsp;
                        <span class="badge rounded-pill bg-secondary float-end me-2">
                            @info.PercentCourcesCompleted
                        </span>
                    </td>
                </tr>

                ix++;
            }
        </tbody>
    </table>

    <br />
    <br />
}










<h3>Raw Data Loader Test</h3>
<p>This page loads the three primary lists using the Cache-or-Fetch pattern you defined.</p>

<hr />

@if (employeeList == null || courseList == null || employeeCourseList == null)
{
    <p><em>Loading data...</em></p>
}
else
{
    <div class="row">
        <div class="col-md-4">
            <h4>Employee Data (Total: @employeeList.Count)</h4>
            @if (employeeList.Any())
            {
                <ul>
                    @foreach (var emp in employeeList.Take(5))
                    {
                        <li>@($"Employee ID: {emp.EmployeeID}, Name: {emp.Name}")</li>
                    }
                </ul>
            }
        </div>
        <div class="col-md-4">
            <h4>Course Data (Total: @courseList.Count)</h4>
            @if (courseList.Any())
            {
                <ul>
                    @foreach (var course in courseList.Take(5))
                    {
                        <li>@($"Course ID: {course.CourseID}, Name: {course.Name}")</li>
                    }
                </ul>
            }
        </div>
        <div class="col-md-4">
            <h4>Junction Data (Total: @employeeCourseList.Count)</h4>
            @if (employeeCourseList.Any())
            {
                <ul>
                    @foreach (var ec in employeeCourseList.Take(5))
                    {
                        <li>@($"EC ID: {ec.EmployeeCourseID}, E ID: {ec.EmployeeID}, C ID: {ec.CourseID}")</li>
                    }
                </ul>
            }
        </div>
    </div>
}

@code {

    private List<EmployeeCourseInfo> employeesCourseInfoList = new();
    private List<EmployeeInfo> employeeInfoList = new();
    private List<CourseInfo> courseInfoList = new();

    // --- RAW DATA LISTS (Targets for JSON/Store) ---
    private List<Employee> employeeList = new();
    private List<Course> courseList = new();
    private List<EmployeeCourse> employeeCourseList = new();

    private const string EmployeeListKey = "EmployeeList_Data";
    private const string CourseListKey = "CourseList_Data";
    private const string EmployeeCourseListKey = "EmployeeCourseList_Data";

    private EmployeeCourseInfo ToEmployeeCourseInfo(
    EmployeeCourse ec,
    List<EmployeeInfo> employeeInfoList, // The pre-built list of EmployeeInfo objects
    List<CourseInfo> courseInfoList)     // The pre-built list of CourseInfo objects
    {
        // 1. Find the corresponding rich Info objects
        EmployeeInfo? employeeInfo = employeeInfoList.FirstOrDefault(e => e.EmployeeID == ec.EmployeeID);
        CourseInfo? courseInfo = courseInfoList.FirstOrDefault(c => c.CourseID == ec.CourseID);

        // CRITICAL: If either object isn't found, you may want to return null or throw an error.
        // For now, we assume they exist, matching your implicit logic.
        if (employeeInfo == null || courseInfo == null)
        {
            // This case indicates orphaned data (a missing Employee or Course)
            return null!; // Return null or handle the error appropriately
        }

        // 2. Map properties from the raw EmployeeCourse object
        EmployeeCourseInfo employeeCourseInfo = new EmployeeCourseInfo
        {
            // Raw properties
            EmployeeCourseID = ec.EmployeeCourseID,
            EmployeeID = ec.EmployeeID,
            CourseID = ec.CourseID,
            isComplete = ec.isComplete,
            CompletedOn = ec.CompletedOn,
            AssignedOn = ec.AssignedOn,
            UpdatedOn = ec.UpdatedOn,

            // Rich Info objects (The join)
            EmployeeInfo = employeeInfo,
            CourseInfo = courseInfo
        };

        return employeeCourseInfo;
    }

    private CourseInfo ToCourseInfo(
       Course course,
       List<EmployeeCourse> employeeCourseList, // The full raw junction list
       List<Employee> employeeList)             // The full raw employee list
    {
        // 1. Map properties from the raw Course object to CourseInfo
        CourseInfo courseInfo = new CourseInfo
        {
            CourseID = course.CourseID,
            RowId = course.RowId,
            Name = course.Name,
            Description = course.Description,
            Code = course.Code,

            // Initialize navigation lists
            // Note: EmployeeList on CourseInfo holds raw Employee objects
            EmployeeList = new List<Employee>(),
            EmployeeCourseList = new List<EmployeeCourse>()
        };

        // 2. Filter the junction table (EmployeeCourse) for this specific course
        List<EmployeeCourse> relatedEmployeeCourses = employeeCourseList
            .Where(ec => ec.CourseID == course.CourseID)
            .ToList();

        // 3. Populate the related Employee objects
        foreach (var ec in relatedEmployeeCourses)
        {
            // Find the matching Employee object in the master list (employeeList)
            // Using FirstOrDefault() is safer than First() in case data is inconsistent
            Employee? employee = employeeList.FirstOrDefault(e => e.EmployeeID == ec.EmployeeID);

            if (employee != null)
            {
                courseInfo.EmployeeList.Add(employee);
            }
        }

        // 4. Assign the filtered junction data
        courseInfo.EmployeeCourseList = relatedEmployeeCourses;

        return courseInfo;
    }

    private EmployeeInfo ToEmployeeInfo(
        Employee employee,
        List<EmployeeCourse> employeeCourseList, // Renamed parameter
        List<Course> courseList)                 // Renamed parameter
    {
        // 1. Map properties from the raw Employee object
        EmployeeInfo employeeInfo = new EmployeeInfo
        {
            EmployeeID = employee.EmployeeID,
            RowId = employee.RowId,
            Name = employee.Name,
            HireDate = employee.HireDate,

            // Initialize navigation lists
            // Note: CourseList on EmployeeInfo holds raw Course objects
            CourseList = new List<Course>(),
            EmployeeCourseList = new List<EmployeeCourse>()
        };

        // 2. Filter the junction table for this specific employee
        List<EmployeeCourse> relatedEmployeeCourses = employeeCourseList
            .Where(ec => ec.EmployeeID == employee.EmployeeID)
            .ToList();

        // 3. Populate the related Course objects
        foreach (var ec in relatedEmployeeCourses)
        {
            // Find the matching Course object in the master list
            Course? course = courseList.FirstOrDefault(c => c.CourseID == ec.CourseID);

            if (course != null)
            {
                employeeInfo.CourseList.Add(course);
            }
        }

        // 4. Assign the filtered junction data
        employeeInfo.EmployeeCourseList = relatedEmployeeCourses;

        return employeeInfo;
    }

    protected override async Task OnInitializedAsync()
    {
        employeesCourseInfoList = null; // Ensure the final list is null for loading state

        // Set raw lists to null for loading indicator (assuming they are class fields)
        employeeList = null!;
        courseList = null!;
        employeeCourseList = null!;

        var httpClient = HttpClientFactory.CreateClient();
        httpClient.BaseAddress = new Uri(NavigationManager.BaseUri);

        try
        {
            // 1. Load RAW Data (The three list<T> fields)
            employeeList = await LoadDataFromCacheOrHttp<List<Employee>>(
                EmployeeListKey,
                "etms-data/EmployeeList.json", httpClient
            ) ?? new List<Employee>();

            courseList = await LoadDataFromCacheOrHttp<List<Course>>(
                CourseListKey,
                "etms-data/CourseList.json", httpClient
            ) ?? new List<Course>();

            employeeCourseList = await LoadDataFromCacheOrHttp<List<EmployeeCourse>>(
                EmployeeCourseListKey,
                "etms-data/EmployeeCourseList.json", httpClient
            ) ?? new List<EmployeeCourse>();

            // Check if data is present before proceeding with conversion/join
            if (employeeList.Any() && courseList.Any() && employeeCourseList.Any())
            {
                // 2. CONVERSION: Build the intermediate Info lists using helper methods

                // Build employeeInfoList
                employeeInfoList = employeeList.Select(emp =>
                    ToEmployeeInfo(emp, employeeCourseList, courseList) // Uses ToEmployeeInfo(Employee, List<EmployeeCourse>, List<Course>)
                ).ToList();

                // Build courseInfoList
                courseInfoList = courseList.Select(crs =>
                    ToCourseInfo(crs, employeeCourseList, employeeList) // Uses ToCourseInfo(Course, List<EmployeeCourse>, List<Employee>)
                ).ToList();

                // 3. FINAL JOIN: Build employeesCourseInfoList

                employeesCourseInfoList = employeeCourseList
                    .Select(ec =>
                        // Uses ToEmployeeCourseInfo(EmployeeCourse, List<EmployeeInfo>, List<CourseInfo>)
                        ToEmployeeCourseInfo(ec, employeeInfoList, courseInfoList)
                    )
                    .Where(x => x != null) // Filter out any records where a join failed (orphaned data)
                    .ToList();

                Console.WriteLine($"Final Joined Display List Count: {employeesCourseInfoList.Count}");
            }
            else
            {
                // If data is missing or empty, initialize the final list as empty
                employeesCourseInfoList = new List<EmployeeCourseInfo>();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FATAL DATA LOAD ERROR: {ex.Message}");
            // Ensure all lists are non-null and empty on failure
            employeeList = new List<Employee>();
            courseList = new List<Course>();
            employeeCourseList = new List<EmployeeCourse>();
            employeesCourseInfoList = new List<EmployeeCourseInfo>();
        }

        employeesCourseInfoList ??= new List<EmployeeCourseInfo>();
        StateHasChanged();
    }

    // --- LoadDataFromCacheOrHttp<T> METHOD (Your Logic) ---
    // This is the core logic that retrieves data from cache (store) OR HTTP (json).
    private async Task<T> LoadDataFromCacheOrHttp<T>(string storageKey, string url, HttpClient httpClient) where T : new()
    {
        // Helper function to serialize and log the first few items of a collection
        void LogDataContents(string source, T dataToLog)
        {
            if (dataToLog is System.Collections.IEnumerable enumerable)
            {
                var collection = enumerable.Cast<object>().ToList();
                var count = collection.Count;
                var sample = collection.Take(3).ToList();

                Console.WriteLine($"--- [DEBUG DATA LOG - {storageKey}] ---");
                Console.WriteLine($"Source: {source}, URL/Key: {(source == "CACHE" ? storageKey : url)}, Total Count: {count}");

                // Log full data for the first three items
                Console.WriteLine($"Sample Data ({sample.Count} items):");
                foreach (var item in sample)
                {
                    var itemJson = System.Text.Json.JsonSerializer.Serialize(item, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
                    Console.WriteLine($"- Item:\n{itemJson}");
                }
                Console.WriteLine("------------------------------------------");
            }
        }


        // --- 1. CHECK LOCAL STORAGE (Cache Read Guarded) ---
        if (LocalStorage != null)
        {
            try
            {
                Console.WriteLine($"[CACHE READ] Attempting to retrieve key: {storageKey}");
                var cachedData = await LocalStorage.GetItemAsync<T>(storageKey);

                if (cachedData != null && !cachedData.Equals(default(T)))
                {
                    // FIX: Check if the collection is empty. If it is, treat it as a cache miss.
                    if (cachedData is System.Collections.ICollection collection && collection.Count == 0)
                    {
                        Console.WriteLine($"[CACHE:EMPTY] {storageKey} found but is empty. Forcing HTTP fetch.");
                        // Fall through to HTTP fetch
                    }
                    else
                    {
                        LogDataContents("CACHE", cachedData);
                        return cachedData; // Cache hit, return valid data
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CACHE ERROR] Failed to read {storageKey} from Local Storage: {ex.Message}");
            }
        }

        // --- 2. FETCH FROM HTTP (If cache failed or was empty) ---
        T data = new T();
        Console.WriteLine($"[HTTP FETCH] Fetching URL: {url}");

        try
        {
            var response = await httpClient.GetAsync(url);
            response.EnsureSuccessStatusCode();

            var jsonContent = await response.Content.ReadAsStringAsync();

            // 🛑 LOGGING FULL RAW JSON CONTENT 🛑
            Console.WriteLine($"[FULL JSON LOG] {storageKey} raw content fetched from URL:");
            // Console.WriteLine(jsonContent); // Keeping this line commented out to reduce overwhelming logs
            // ---------------------------------

            // Deserialization happens here
            data = System.Text.Json.JsonSerializer.Deserialize<T>(jsonContent) ?? new T();

            // Log the deserialized C# object content
            LogDataContents("HTTP JSON", data);

            // --- 3. SAVE TO CACHE ---
            if (LocalStorage != null && !data.Equals(default(T)))
            {
                try
                {
                    await LocalStorage.SetItemAsync(storageKey, data);
                    Console.WriteLine($"[CACHE WRITE] Successfully saved {storageKey} to Local Storage.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[CACHE WRITE ERROR] Failed to save {storageKey}: {ex.Message}");
                }
            }

            return data;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[HTTP ERROR] Failed to fetch or deserialize {url}: {ex.Message}");
            return new T();
        }
    }
}